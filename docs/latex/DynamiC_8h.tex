\hypertarget{DynamiC_8h}{}\doxysection{Data\+\_\+\+Structures/\+Dynami\+C/src/\+DynamiC.h File Reference}
\label{DynamiC_8h}\index{Data\_Structures/DynamiC/src/DynamiC.h@{Data\_Structures/DynamiC/src/DynamiC.h}}


Specification of \mbox{\hyperlink{structDynamiC}{DynamiC}}.  


{\ttfamily \#include $<$stddef.\+h$>$}\newline
Include dependency graph for Dynami\+C.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=212pt]{DynamiC_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{DynamiC_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{structDynamiC}{DynamiC}}
\begin{DoxyCompactList}\small\item\em Our main struct that contains all the data and metainfo about our dynamic array. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{DynamiC_8h_a523d971724d531776bd68b46b1d9ac09}{FLTEPSILON}}~0.\+001
\begin{DoxyCompactList}\small\item\em Global epsilons to be used when comparing floating-\/point values. If you need to change how precise the comparisons should be, change it here. Used in the following functions \+\_\+find() \+\_\+cmp() \end{DoxyCompactList}\item 
\mbox{\Hypertarget{DynamiC_8h_af4973b3c510aebce805cc83c65def4ef}\label{DynamiC_8h_af4973b3c510aebce805cc83c65def4ef}} 
\#define {\bfseries DBEPSILON}~0.\+000001
\item 
\#define {\bfseries min}(a,  b)
\end{DoxyCompactItemize}
\doxysubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{DynamiC_8h_a3af1a69ba69534fcd66b70a983ddc72d}\label{DynamiC_8h_a3af1a69ba69534fcd66b70a983ddc72d}} 
typedef enum Error\+Code {\bfseries Error\+Code}
\item 
\mbox{\Hypertarget{DynamiC_8h_afe6a2898ea39c4858f05f44227346d52}\label{DynamiC_8h_afe6a2898ea39c4858f05f44227346d52}} 
typedef struct \mbox{\hyperlink{structDynamiC}{DynamiC}} {\bfseries DynamiC}
\end{DoxyCompactItemize}
\doxysubsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{DynamiC_8h_a59e56af19e754a6aa26a612ebf91d05f}\label{DynamiC_8h_a59e56af19e754a6aa26a612ebf91d05f}} 
enum {\bfseries Error\+Code} \{ \newline
{\bfseries SUCCESS} = 0
, {\bfseries OUT\+\_\+\+OF\+\_\+\+MEMORY}
, {\bfseries INVALID\+\_\+\+ARGUMENT}
, {\bfseries INVALID\+\_\+\+DATATYPE}
, \newline
{\bfseries OUT\+\_\+\+OF\+\_\+\+BOUNDS\+\_\+\+INDEX}
, {\bfseries UNKNOWN\+\_\+\+ERROR}
, {\bfseries E\+\_\+\+SUCCESS} = 0
, {\bfseries E\+\_\+\+OUT\+\_\+\+OF\+\_\+\+MEMORY}
, \newline
{\bfseries E\+\_\+\+INVALID\+\_\+\+ARGUMENT}
, {\bfseries E\+\_\+\+INVALID\+\_\+\+DATATYPE}
, {\bfseries E\+\_\+\+OUT\+\_\+\+OF\+\_\+\+BOUNDS\+\_\+\+INDEX}
, {\bfseries E\+\_\+\+UNKNOWN\+\_\+\+ERROR}
, \newline
{\bfseries E\+\_\+\+ERROR\+\_\+\+COUNT}
 \}
\end{DoxyCompactItemize}
\doxysubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$ \mbox{\hyperlink{DynamiC_8h_ad8606d55b9cb283a4f848446d9163669}{Dynami\+C\+\_\+init}} (void $\ast$data, size\+\_\+t data\+\_\+size, size\+\_\+t num\+\_\+elems)
\begin{DoxyCompactList}\small\item\em Initializes our dynamic array. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{DynamiC_8h_a16002f8f4c909dfa6eab51c62995971e}{Dynami\+C\+\_\+size}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array)
\begin{DoxyCompactList}\small\item\em Returns the number of elements currently in the array. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{DynamiC_8h_a106a046307b9b93652580edbaf641616}{Dynami\+C\+\_\+append}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array, void $\ast$elem)
\begin{DoxyCompactList}\small\item\em Appends the given element to the end of the array, automatically resizing the array if necessary. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{DynamiC_8h_a836ed8df3987f5e12785f3a2ff3ebf4a}{Dynami\+C\+\_\+delete}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$$\ast$array)
\begin{DoxyCompactList}\small\item\em Frees up all memory used by the array including the struct itself. Pass a reference to the \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer, that way everything will be NULL\textquotesingle{}d safely. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{DynamiC_8h_ae4226241f4d3e615e98c8bc0f485c012}{Dynami\+C\+\_\+remove}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Removes from the array a single element. Reduces the size of the array by 1 and closes the gap by shifting every element over by 1. The capacity remains unchanged after this operation. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{DynamiC_8h_a9fb39b89fe70436bc5d9bc0674b8b193}{Dynami\+C\+\_\+empty}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array)
\begin{DoxyCompactList}\small\item\em Clears out the entire array, reducing the size to 0. Does not change the capacity in any way. \end{DoxyCompactList}\item 
void $\ast$ \mbox{\hyperlink{DynamiC_8h_a5d45fde098aadb02481a4ed3534fb482}{Dynami\+C\+\_\+get}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Retrieves the element at the specified index. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{DynamiC_8h_aa6f27a0dc3df28f051c09aca0695d112}{Dynami\+C\+\_\+insert}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array, void $\ast$elem, size\+\_\+t index)
\begin{DoxyCompactList}\small\item\em Inserts an element at the chosen index. This effectively shifts all existing elements over. Automatically reallocates memory if needed. If index equals size, it will basically act as \+\_\+append() would. \end{DoxyCompactList}\item 
size\+\_\+t \mbox{\hyperlink{DynamiC_8h_abea8f34622962bbc9d871b91bc72eabe}{Dynami\+C\+\_\+find}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array, void $\ast$data, int($\ast$Dynami\+C\+\_\+cmp)(const void $\ast$elem1, const void $\ast$elem2))
\begin{DoxyCompactList}\small\item\em Attempts to linearly search through the array for the given data. Because of the generic nature of the array, a comparator function must be provided for this function to work with any data types. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{DynamiC_8h_a76201441ca0c75ddc00c0b720b9e9f41}{Dynami\+C\+\_\+resize}} (\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$array)
\begin{DoxyCompactList}\small\item\em Attempts to resize the array by doubling the current capacity and realloc\textquotesingle{}ing the pointer. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Specification of \mbox{\hyperlink{structDynamiC}{DynamiC}}. 

\begin{DoxyAuthor}{Author}
Kevin Pluas (\href{mailto:kpluas21@gmail.com}{\texttt{ kpluas21@gmail.\+com}}) 
\end{DoxyAuthor}
\begin{DoxyVersion}{Version}
0.\+1 
\end{DoxyVersion}
\begin{DoxyDate}{Date}
2023-\/04-\/02
\end{DoxyDate}
\begin{DoxyCopyright}{Copyright}
Copyright (c) 2023
\end{DoxyCopyright}
This structure uses mostly void pointers and regular arrays. It handles ints, chars, doubles and floats. Strings are to be implemented soonish... Everything you need should be in this one header file. Simply include it and call the \+\_\+init function. Make sure to include what type you are gonna use the array for. This was not tested for every outcome, for instance, if one should init an array of chars while labeling it as a float. Its up to YOU to know what you\textquotesingle{}re doing.

Because this was created using LOTS of void pointers, expect to see and use a lot of casting, again, it should work if you\textquotesingle{}re casting appropriately.

Dynami\+Cs are zero-\/based and are designed with fast insertion in mind. Appending should occur in constant time unless capacity was reached in which case it will automatically resize and attempt to append the element again. 

\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{DynamiC_8h_a523d971724d531776bd68b46b1d9ac09}\label{DynamiC_8h_a523d971724d531776bd68b46b1d9ac09}} 
\index{DynamiC.h@{DynamiC.h}!FLTEPSILON@{FLTEPSILON}}
\index{FLTEPSILON@{FLTEPSILON}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{FLTEPSILON}{FLTEPSILON}}
{\footnotesize\ttfamily \#define FLTEPSILON~0.\+001}



Global epsilons to be used when comparing floating-\/point values. If you need to change how precise the comparisons should be, change it here. Used in the following functions \+\_\+find() \+\_\+cmp() 


\begin{DoxyItemize}
\item 1) remove \+: Removes an element from the array , everything will have to be stitched together 
\end{DoxyItemize}\mbox{\Hypertarget{DynamiC_8h_ac6afabdc09a49a433ee19d8a9486056d}\label{DynamiC_8h_ac6afabdc09a49a433ee19d8a9486056d}} 
\index{DynamiC.h@{DynamiC.h}!min@{min}}
\index{min@{min}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{min}{min}}
{\footnotesize\ttfamily \#define min(\begin{DoxyParamCaption}\item[{}]{a,  }\item[{}]{b }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    (\{ \_\_typeof\_\_ (a) \_a = (a); \(\backslash\)}
\DoxyCodeLine{        \_\_typeof\_\_ (b) \_b = (b); \(\backslash\)}
\DoxyCodeLine{        \_a < \_b ? \_a : \_b; \})}

\end{DoxyCode}


\doxysubsection{Function Documentation}
\mbox{\Hypertarget{DynamiC_8h_a106a046307b9b93652580edbaf641616}\label{DynamiC_8h_a106a046307b9b93652580edbaf641616}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_append@{DynamiC\_append}}
\index{DynamiC\_append@{DynamiC\_append}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_append()}{DynamiC\_append()}}
{\footnotesize\ttfamily void Dynami\+C\+\_\+append (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array,  }\item[{void $\ast$}]{elem }\end{DoxyParamCaption})}



Appends the given element to the end of the array, automatically resizing the array if necessary. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
{\em elem} & The element to be added \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{DynamiC_8h_a836ed8df3987f5e12785f3a2ff3ebf4a}\label{DynamiC_8h_a836ed8df3987f5e12785f3a2ff3ebf4a}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_delete@{DynamiC\_delete}}
\index{DynamiC\_delete@{DynamiC\_delete}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_delete()}{DynamiC\_delete()}}
{\footnotesize\ttfamily void Dynami\+C\+\_\+delete (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$$\ast$}]{array }\end{DoxyParamCaption})}



Frees up all memory used by the array including the struct itself. Pass a reference to the \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer, that way everything will be NULL\textquotesingle{}d safely. 


\begin{DoxyParams}{Parameters}
{\em array} & A pointer to a \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{DynamiC_8h_a9fb39b89fe70436bc5d9bc0674b8b193}\label{DynamiC_8h_a9fb39b89fe70436bc5d9bc0674b8b193}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_empty@{DynamiC\_empty}}
\index{DynamiC\_empty@{DynamiC\_empty}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_empty()}{DynamiC\_empty()}}
{\footnotesize\ttfamily void Dynami\+C\+\_\+empty (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array }\end{DoxyParamCaption})}



Clears out the entire array, reducing the size to 0. Does not change the capacity in any way. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{DynamiC_8h_abea8f34622962bbc9d871b91bc72eabe}\label{DynamiC_8h_abea8f34622962bbc9d871b91bc72eabe}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_find@{DynamiC\_find}}
\index{DynamiC\_find@{DynamiC\_find}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_find()}{DynamiC\_find()}}
{\footnotesize\ttfamily size\+\_\+t Dynami\+C\+\_\+find (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array,  }\item[{void $\ast$}]{data,  }\item[{int($\ast$)(const void $\ast$elem1, const void $\ast$elem2)}]{Dynami\+C\+\_\+cmp }\end{DoxyParamCaption})}



Attempts to linearly search through the array for the given data. Because of the generic nature of the array, a comparator function must be provided for this function to work with any data types. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
{\em data} & The data to search for \\
\hline
{\em Dynami\+C\+\_\+cmp} & A pointer to a comparator function \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size\+\_\+t The index where the data is located. 
\end{DoxyReturn}
\mbox{\Hypertarget{DynamiC_8h_a5d45fde098aadb02481a4ed3534fb482}\label{DynamiC_8h_a5d45fde098aadb02481a4ed3534fb482}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_get@{DynamiC\_get}}
\index{DynamiC\_get@{DynamiC\_get}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_get()}{DynamiC\_get()}}
{\footnotesize\ttfamily void$\ast$ Dynami\+C\+\_\+get (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array,  }\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}



Retrieves the element at the specified index. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
{\em index} & Index of the element \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
void$\ast$ A void pointer that points to the result of this function call. 
\end{DoxyReturn}
\mbox{\Hypertarget{DynamiC_8h_ad8606d55b9cb283a4f848446d9163669}\label{DynamiC_8h_ad8606d55b9cb283a4f848446d9163669}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_init@{DynamiC\_init}}
\index{DynamiC\_init@{DynamiC\_init}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_init()}{DynamiC\_init()}}
{\footnotesize\ttfamily \mbox{\hyperlink{structDynamiC}{DynamiC}}$\ast$ Dynami\+C\+\_\+init (\begin{DoxyParamCaption}\item[{void $\ast$}]{data,  }\item[{size\+\_\+t}]{data\+\_\+size,  }\item[{size\+\_\+t}]{num\+\_\+elems }\end{DoxyParamCaption})}



Initializes our dynamic array. 


\begin{DoxyParams}{Parameters}
{\em data} & The void pointer to our initial data. \\
\hline
{\em data\+\_\+size} & The size, in bytes, each element is. \\
\hline
{\em num\+\_\+elems} & The number of elements in our initial array/pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Dynami\+C$\ast$ A pointer to your newly created dynamic array. 
\end{DoxyReturn}
\mbox{\Hypertarget{DynamiC_8h_aa6f27a0dc3df28f051c09aca0695d112}\label{DynamiC_8h_aa6f27a0dc3df28f051c09aca0695d112}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_insert@{DynamiC\_insert}}
\index{DynamiC\_insert@{DynamiC\_insert}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_insert()}{DynamiC\_insert()}}
{\footnotesize\ttfamily int Dynami\+C\+\_\+insert (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array,  }\item[{void $\ast$}]{elem,  }\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}



Inserts an element at the chosen index. This effectively shifts all existing elements over. Automatically reallocates memory if needed. If index equals size, it will basically act as \+\_\+append() would. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
{\em elem} & The element to be inserted \\
\hline
{\em index} & The location where the element is to be inserted \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
int Returns 0 if successful, $<$0 if error encountered. 
\end{DoxyReturn}
\mbox{\Hypertarget{DynamiC_8h_ae4226241f4d3e615e98c8bc0f485c012}\label{DynamiC_8h_ae4226241f4d3e615e98c8bc0f485c012}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_remove@{DynamiC\_remove}}
\index{DynamiC\_remove@{DynamiC\_remove}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_remove()}{DynamiC\_remove()}}
{\footnotesize\ttfamily void Dynami\+C\+\_\+remove (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array,  }\item[{size\+\_\+t}]{index }\end{DoxyParamCaption})}



Removes from the array a single element. Reduces the size of the array by 1 and closes the gap by shifting every element over by 1. The capacity remains unchanged after this operation. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
{\em index} & The index of the element \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{DynamiC_8h_a76201441ca0c75ddc00c0b720b9e9f41}\label{DynamiC_8h_a76201441ca0c75ddc00c0b720b9e9f41}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_resize@{DynamiC\_resize}}
\index{DynamiC\_resize@{DynamiC\_resize}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_resize()}{DynamiC\_resize()}}
{\footnotesize\ttfamily void Dynami\+C\+\_\+resize (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array }\end{DoxyParamCaption})}



Attempts to resize the array by doubling the current capacity and realloc\textquotesingle{}ing the pointer. 


\begin{DoxyParams}{Parameters}
{\em array} & The \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Dynami\+C$\ast$ A pointer to the struct with the newly realloc\textquotesingle{}d data pointer. 
\end{DoxyReturn}
\mbox{\Hypertarget{DynamiC_8h_a16002f8f4c909dfa6eab51c62995971e}\label{DynamiC_8h_a16002f8f4c909dfa6eab51c62995971e}} 
\index{DynamiC.h@{DynamiC.h}!DynamiC\_size@{DynamiC\_size}}
\index{DynamiC\_size@{DynamiC\_size}!DynamiC.h@{DynamiC.h}}
\doxysubsubsection{\texorpdfstring{DynamiC\_size()}{DynamiC\_size()}}
{\footnotesize\ttfamily size\+\_\+t Dynami\+C\+\_\+size (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{structDynamiC}{DynamiC}} $\ast$}]{array }\end{DoxyParamCaption})}



Returns the number of elements currently in the array. 


\begin{DoxyParams}{Parameters}
{\em array} & Our \mbox{\hyperlink{structDynamiC}{DynamiC}} pointer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
size\+\_\+t The number of elements 
\end{DoxyReturn}
